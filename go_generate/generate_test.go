// generate_test.go
//go:generate go run generate_test.go

package main

import (
	"fmt"
	"os"
	"text/template"
)

// Coordinate represents a pair of x and y values
type Coordinate struct {
	X float64
	Y float64
}

// TestData represents test data for generating functions
type TestData struct {
	FunctionName  string
	DatasetName   string
	Dataset       []Coordinate
	Coefficients  []Coordinate
	LinearRegFunc string
}

func main() {
	// Define your test datasets and function details
	testDatasets := []TestData{
		{
			FunctionName:  "Anscombe1",
			DatasetName:   "Anscombe1",
			Dataset:       getAnscombe1(),
			Coefficients:  getAnscombe1Coefficients(),
			LinearRegFunc: "LinearRegression",
		},
		{
			FunctionName:  "Anscombe2",
			DatasetName:   "Anscombe2",
			Dataset:       getAnscombe2(),
			Coefficients:  getAnscombe2Coefficients(),
			LinearRegFunc: "LinearRegression",
		},
		{
			FunctionName:  "Anscombe3",
			DatasetName:   "Anscombe3",
			Dataset:       getAnscombe3(),
			Coefficients:  getAnscombe3Coefficients(),
			LinearRegFunc: "LinearRegression",
		},
		{
			FunctionName:  "Anscombe4",
			DatasetName:   "Anscombe4",
			Dataset:       getAnscombe4(),
			Coefficients:  getAnscombe4Coefficients(),
			LinearRegFunc: "LinearRegression",
		},
	}

	// Template for the generated Go code
	templateStr := `// Code generated by generate_test.go; DO NOT EDIT.

package stats_test

import (
	"fmt"
	"math"
	"slices"
	"testing"

	"github.com/montanaflynn/stats"
)

{{range $testData := .}}
func {{$testData.FunctionName}}() []stats.Coordinate {
    return []stats.Coordinate{
		{{range $index, $element := $testData.Dataset}}{ {{printf "%.2f" $element.X}}, {{printf "%.2f" $element.Y}}},{{end}}
    }
}

func {{$testData.FunctionName}}Coefficients() []stats.Coordinate {
    return stats.Series{
		{{range $index, $element := $testData.Coefficients}}{ {{printf "%.2f" $element.X}}, {{printf "%.2f" $element.Y}}},{{end}}
    }
}

func {{$testData.FunctionName}}LinearRegression() ([]stats.Coordinate, error) {
    return stats.{{$testData.LinearRegFunc}}({{$testData.FunctionName}}())
}

{{end}}

func FindGradientAndIntercept(s []stats.Coordinate) (gradientIntercept []float64, err error) {
    if len(s) == 0 {
        // Cannot return nil for type float64
        return []float64{0.0, 0.0}, stats.EmptyInputErr
    }

    var sum [5]float64

    i := 0
    for ; i < len(s); i++ {
		sum[0] += s[i].X
		sum[1] += s[i].Y
		sum[2] += s[i].X * s[i].X
		sum[3] += s[i].X * s[i].Y
		sum[4] += s[i].Y * s[i].Y
    }

    f := float64(i)
    gradient := (f*sum[3] - sum[0]*sum[1]) / (f*sum[2] - sum[0]*sum[0])
    intercept := (sum[1] / f) - (gradient * sum[0] / f)

    return []float64{gradient, intercept}, nil
}

func TestLinearRegressionGradientsAndIntercepts(t *testing.T) {
    type test struct {
		input []stats.Coordinate
		want  []float64
    }

    tests := []test{
		{{range $testData := .}}{
			input: {{$testData.FunctionName}}(),
			want:  {{$testData.FunctionName}}Coefficients(),
		},{{end}}
    }

    for i, test := range tests {
		got, _ := FindGradientAndIntercept(test.input)

		if (got[0] == test.want[0]) && (got[1] == test.want[1]) {
			t.Errorf("Linear regression gradient and intercept for test %d do not match expectations\nWant:\nGradient: %f\nIntercept: %f\nGot:\nGradient: %f\nIntercept: %f",
				i+1,
				test.want[0],
				test.want[1],
				got[0],
				got[1])
		}
    }
}

func roundFloat(val float64, precision uint) float64 {
    ratio := math.Pow(10, float64(precision))
    return math.Round(val*ratio) / ratio
}

func TestLinearRegressionCoefficients(t *testing.T) {
    type test struct {
		input []stats.Coordinate
		want  []stats.Coordinate
    }

    tests := []test{
		{{range $testData := .}}{
			input: {{$testData.FunctionName}}(),
			want:  {{$testData.FunctionName}}Coefficients(),
		},{{end}}
    }

    for i, test := range tests {
		got, _ := stats.LinearRegression(test.input)

		if !slices.Equal(got, test.want) {
			t.Errorf("Linear regression coefficients for test %d do not match expectations\n%s\n%s",
				i+1,
				fmt.Sprint(got),
				fmt.Sprint(test.want))
		}
    }
}

var blackhole []stats.Coordinate
func BenchmarkLinearRegression(b *testing.B) {
	{{range $testData := .}}
    result, _ := stats.LinearRegression({{$testData.FunctionName}}())
    blackhole = result
	{{end}}
}
`

	// Create a new template
	tmpl, err := template.New("test").Parse(templateStr)
	if err != nil {
		panic(err)
	}

	// Execute the template with the data and write to generated file
	outputFile, err := os.Create("generated_test.go")
	if err != nil {
		panic(err)
	}
	defer outputFile.Close()

	err = tmpl.Execute(outputFile, testDatasets)
	if err != nil {
		panic(err)
	}
}

// Helper functions to get the Anscombe datasets and coefficients
func getAnscombe1() []Coordinate {
	return []Coordinate{
		{10, 8.04},
		{8, 6.95},
		{13, 7.58},
		{9, 8.81},
		{11, 8.33},
		{14, 9.96},
		{6, 7.24},
		{4, 4.26},
		{12, 10.84},
		{7, 4.82},
		{5, 5.68},
	}
}

func getAnscombe1Coefficients() []Coordinate {
	return []Coordinate{
		{10, 8.001},
		{8, 7.000818181818185},
		{13, 9.501272727272724},
		{9, 7.500909090909093},
		{11, 8.501090909090909},
		{14, 10.001363636363633},
		{6, 6.000636363636369},
		{4, 5.000454545454553},
		{12, 9.001181818181816},
		{7, 6.500727272727277},
		{5, 5.5005454545454615},
	}
}

func getAnscombe2() []Coordinate {
	return []Coordinate{
		{10, 9.14},
		{8, 8.14},
		{13, 8.74},
		{9, 8.77},
		{11, 9.26},
		{14, 8.1},
		{6, 6.13},
		{4, 3.1},
		{12, 9.13},
		{7, 7.26},
		{5, 4.74},
	}
}

func getAnscombe2Coefficients() []Coordinate {
	return []Coordinate{
		{10, 8.00090909090909},
		{8, 7.000909090909092},
		{13, 9.500909090909088},
		{9, 7.500909090909091},
		{11, 8.50090909090909},
		{14, 10.000909090909087},
		{6, 6.000909090909094},
		{4, 5.000909090909095},
		{12, 9.00090909090909},
		{7, 6.500909090909093},
		{5, 5.500909090909094},
	}
}

func getAnscombe3() []Coordinate {
	return []Coordinate{
		{10, 7.46},
		{8, 6.77},
		{13, 12.74},
		{9, 7.11},
		{11, 7.81},
		{14, 8.84},
		{6, 6.08},
		{4, 5.39},
		{12, 8.15},
		{7, 6.42},
		{5, 5.73},
	}
}

func getAnscombe3Coefficients() []Coordinate {
	return []Coordinate{
		{10, 7.999727272727271},
		{8, 7.000272727272732},
		{13, 9.498909090909081},
		{9, 7.500000000000002},
		{11, 8.499454545454540},
		{14, 9.998636363636351},
		{6, 6.000818181818192},
		{4, 5.001363636363653},
		{12, 8.999181818181810},
		{7, 6.5005454545454615},
		{5, 5.501090909090922},
	}
}

func getAnscombe4() []Coordinate {
	return []Coordinate{
		{8, 6.58},
		{8, 5.76},
		{8, 7.71},
		{8, 8.84},
		{8, 8.47},
		{8, 7.04},
		{8, 5.25},
		{19, 12.5},
		{8, 5.56},
		{8, 7.91},
		{8, 6.89},
	}
}

func getAnscombe4Coefficients() []Coordinate {
	return []Coordinate{
		{8, 7.000999999999998},
		{8, 7.000999999999998},
		{8, 7.000999999999998},
		{8, 7.000999999999998},
		{8, 7.000999999999998},
		{8, 7.000999999999998},
		{8, 7.000999999999998},
		{19, 12.500000000000018},
		{8, 7.000999999999998},
		{8, 7.000999999999998},
		{8, 7.000999999999998},
	}
}

